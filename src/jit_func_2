#ifdef __MIRC__
#endif
#define FRAMES_MAX 64
#define STACK_MAX (FRAMES_MAX * 256)
#define TAG_NIL 1
#define TAG_FALSE 2
#define TAG_TRUE  3
typedef char bool;
typedef unsigned long int uint64_t;
typedef unsigned long int uintptr_t;
typedef uint64_t Value;
typedef unsigned char uint8_t;
typedef unsigned int uint32_t;
typedef unsigned long long size_t;
#define SIGN_BIT ((uint64_t)0x8000000000000000)
#define QNAN     ((uint64_t)0x7ffc000000000000)
#define OBJ_VAL(obj)    (Value)(SIGN_BIT | QNAN | (uint64_t)(uintptr_t)(obj))
#define NIL_VAL         ((Value)(uint64_t)(QNAN | TAG_NIL))
#define BOOL_VAL(b)     ((b) ? TRUE_VAL : FALSE_VAL)
#define FALSE_VAL       ((Value)(uint64_t)(QNAN | TAG_FALSE))
#define TRUE_VAL        ((Value)(uint64_t)(QNAN | TAG_TRUE))
#define NUMBER_VAL(num) numToValue(num)
#define AS_NUMBER(value)    valueToNum(value)
#define AS_OBJ(value)       ((Obj*)(uintptr_t)((value) & ~(SIGN_BIT | QNAN)))
#define IS_NUMBER(value)    (((value) & QNAN) != QNAN)
#define IS_STRING(value) isObjType(value, OBJ_STRING)
#define IS_OBJ(value)       (((value) & (QNAN | SIGN_BIT)) == (QNAN | SIGN_BIT))
#define true 1
#define false 0

typedef enum {
   OBJ_BOUND_METHOD,
   OBJ_CLASS,
   OBJ_CLOSURE,
   OBJ_FUNCTION,
   OBJ_INSTANCE,
   OBJ_NATIVE,
   OBJ_STRING,
   OBJ_UPVALUE,
} ObjType;

typedef enum {
   INTERPRET_OK,
   INTERPRET_COMPILE_ERROR,
   INTERPRET_RUNTIME_ERROR
} InterpretResult;

typedef struct Obj {
   ObjType type;
   bool isMarked;
   struct Obj *next;
} Obj;

typedef struct {
    int capacity;
    int count;
    Value* values;
} ValueArray;

typedef struct {
   int count;
   int capacity;
   uint8_t* code;
   int* lines;
   ValueArray constants;
} Chunk;

typedef struct {
   Obj obj;
   int length;
   char *chars;
   uint32_t hash;
} ObjString;

typedef struct {
   Obj obj;
   int arity;
   int upvalueCount;
   Chunk chunk;
   ObjString *name;
} ObjFunction;

typedef struct ObjUpvalue {
   Obj obj;
   Value *location;
   Value closed;
   struct ObjUpvalue *next;
} ObjUpvalue;

typedef struct {
   Obj obj;
   ObjFunction *function;
   ObjUpvalue **upvalues;
   int upvalueCount;
   int(*jitFunction)(void*);
   int execCount;
} ObjClosure;

typedef struct {
   ObjClosure* closure;
   uint8_t* ip;
   Value* slots;
} CallFrame;

typedef struct {
   ObjString *key;
   Value value;
} Entry;

typedef struct {
   int count;
   int capacity;
   Entry *entries;
} Table;

typedef struct {
   CallFrame frames[FRAMES_MAX];
   int frameCount;
   Value stack[STACK_MAX];
   Value* stackTop;
   Table globals;
   Table strings;
   ObjString* initString;
   ObjUpvalue* openUpvalues;
   size_t bytesAllocated;
   size_t nextGC;
   Obj* objects;
   int grayCount;
   int grayCapacity;
   Obj** grayStack;
} VM;

Value pop();
void push(Value);
Value peek(int distance);
void runtimeError(const char *, ...);
bool tableGet(Table *, ObjString *, Value *);
bool tableSet(Table *, ObjString *, Value);
void closeUpvalues(Value *);
ObjClosure *newClosure(ObjFunction *);
bool callValue(Value, int);
bool isFalsey(Value);
void concatenate();
double valueToNum(Value);
Value numToValue(double);
bool isObjType(Value, ObjType);
void printValue(Value value);
int printf (const char *__restrict __fmt, ...);


int jit_func_2 (VM *vm, ObjClosure* _closure) {
  CallFrame *frame = &vm->frames[vm->frameCount++];
  frame->closure = _closure;
  frame->ip = _closure->function->chunk.code;
  frame->slots = vm->stackTop - 1 - 1;
  ObjString *name;
  Value constant,value,result;
  uint8_t slot;
  double a,b;
  constant = 4607182418800017408UL;
  push(constant);
  constant = 0UL;
  push(constant);
Label_4:
  slot = 3;
  push(frame->slots[slot]);
  slot = 1;
  push(frame->slots[slot]);
  if (!IS_NUMBER(peek(0)) || !IS_NUMBER(peek(1))) {
      runtimeError("Operands must be numbers.");
      return INTERPRET_RUNTIME_ERROR; 
  }
  b = AS_NUMBER(pop());
  a = AS_NUMBER(pop());
  push(BOOL_VAL(a < b)); 
  if (isFalsey(peek(0)))
      goto Label_38;
  pop();
  goto Label_27;
Label_16:
  slot = 3;
  push(frame->slots[slot]);
  constant = 4607182418800017408UL;
  push(constant);
  if (IS_STRING(peek(0)) && IS_STRING(peek(1))) {
      concatenate();
  } else if (IS_NUMBER(peek(0)) && IS_NUMBER(peek(1))) {
      double b = AS_NUMBER(pop());
      double a = AS_NUMBER(pop());
      push(NUMBER_VAL(a + b));
  } else {
      runtimeError("Operands must be two numbers or two strings.");
      return INTERPRET_RUNTIME_ERROR;
  }
  slot = 3;
  frame->slots[slot] = peek(0);
  pop();
  goto Label_4;
Label_27:
  slot = 2;
  push(frame->slots[slot]);
  slot = 3;
  push(frame->slots[slot]);
  if (IS_STRING(peek(0)) && IS_STRING(peek(1))) {
      concatenate();
  } else if (IS_NUMBER(peek(0)) && IS_NUMBER(peek(1))) {
      double b = AS_NUMBER(pop());
      double a = AS_NUMBER(pop());
      push(NUMBER_VAL(a + b));
  } else {
      runtimeError("Operands must be two numbers or two strings.");
      return INTERPRET_RUNTIME_ERROR;
  }
  slot = 2;
  frame->slots[slot] = peek(0);
  pop();
  goto Label_16;
Label_38:
  pop();
  pop();
  push(NIL_VAL);
  result = pop();
  closeUpvalues(frame->slots);
  vm->frameCount--;
  if (vm->frameCount == 0) {
      pop();
      return INTERPRET_OK;
  }
  vm->stackTop = frame->slots;
  push(result);
  frame = &vm->frames[vm->frameCount - 1];
  return INTERPRET_OK;
  constant = 4607182418800017408UL;
  push(constant);
  return INTERPRET_OK;
}

