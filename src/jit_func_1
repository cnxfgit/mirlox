#ifdef __MIRC__
#endif
#define FRAMES_MAX 64
#define STACK_MAX (FRAMES_MAX * 256)
#define TAG_NIL 1
#define TAG_FALSE 2
#define TAG_TRUE  3
typedef char bool;
typedef unsigned long int uint64_t;
typedef unsigned long int uintptr_t;
typedef uint64_t Value;
typedef unsigned char uint8_t;
typedef unsigned int uint32_t;
typedef unsigned long long size_t;
#define SIGN_BIT ((uint64_t)0x8000000000000000)
#define QNAN     ((uint64_t)0x7ffc000000000000)
#define OBJ_VAL(obj)    (Value)(SIGN_BIT | QNAN | (uint64_t)(uintptr_t)(obj))
#define NIL_VAL         ((Value)(uint64_t)(QNAN | TAG_NIL))
#define BOOL_VAL(b)     ((b) ? TRUE_VAL : FALSE_VAL)
#define FALSE_VAL       ((Value)(uint64_t)(QNAN | TAG_FALSE))
#define TRUE_VAL        ((Value)(uint64_t)(QNAN | TAG_TRUE))
#define NUMBER_VAL(num) numToValue(num)
#define AS_NUMBER(value)    valueToNum(value)
#define AS_OBJ(value)       ((Obj*)(uintptr_t)((value) & ~(SIGN_BIT | QNAN)))
#define IS_NUMBER(value)    (((value) & QNAN) != QNAN)
#define IS_STRING(value) isObjType(value, OBJ_STRING)
#define IS_OBJ(value)       (((value) & (QNAN | SIGN_BIT)) == (QNAN | SIGN_BIT))
#define true 1
#define false 0

typedef enum {
   OBJ_BOUND_METHOD,
   OBJ_CLASS,
   OBJ_CLOSURE,
   OBJ_FUNCTION,
   OBJ_INSTANCE,
   OBJ_NATIVE,
   OBJ_STRING,
   OBJ_UPVALUE,
} ObjType;

typedef enum {
   INTERPRET_OK,
   INTERPRET_COMPILE_ERROR,
   INTERPRET_RUNTIME_ERROR
} InterpretResult;

typedef struct Obj {
   ObjType type;
   bool isMarked;
   struct Obj *next;
} Obj;

typedef struct {
    int capacity;
    int count;
    Value* values;
} ValueArray;

typedef struct {
   int count;
   int capacity;
   uint8_t* code;
   int* lines;
   ValueArray constants;
} Chunk;

typedef struct {
   Obj obj;
   int length;
   char *chars;
   uint32_t hash;
} ObjString;

typedef struct {
   Obj obj;
   int arity;
   int upvalueCount;
   Chunk chunk;
   ObjString *name;
} ObjFunction;

typedef struct ObjUpvalue {
   Obj obj;
   Value *location;
   Value closed;
   struct ObjUpvalue *next;
} ObjUpvalue;

typedef struct {
   Obj obj;
   ObjFunction *function;
   ObjUpvalue **upvalues;
   int upvalueCount;
   int(*jitFunction)(void*);
   int execCount;
} ObjClosure;

typedef struct {
   ObjClosure* closure;
   uint8_t* ip;
   Value* slots;
} CallFrame;

typedef struct {
   ObjString *key;
   Value value;
} Entry;

typedef struct {
   int count;
   int capacity;
   Entry *entries;
} Table;

typedef struct {
   CallFrame frames[FRAMES_MAX];
   int frameCount;
   Value stack[STACK_MAX];
   Value* stackTop;
   Table globals;
   Table strings;
   ObjString* initString;
   ObjUpvalue* openUpvalues;
   size_t bytesAllocated;
   size_t nextGC;
   Obj* objects;
   int grayCount;
   int grayCapacity;
   Obj** grayStack;
} VM;

Value pop();
void push(Value);
Value peek(int distance);
void runtimeError(const char *, ...);
bool tableGet(Table *, ObjString *, Value *);
bool tableSet(Table *, ObjString *, Value);
void closeUpvalues(Value *);
ObjClosure *newClosure(ObjFunction *);
bool callValue(Value, int);
bool isFalsey(Value);
void concatenate();
double valueToNum(Value);
Value numToValue(double);
bool isObjType(Value, ObjType);
void printValue(Value value);
int printf (const char *__restrict __fmt, ...);


int jit_func_1 (VM *vm, ObjClosure* _closure) {
  CallFrame *frame = &vm->frames[vm->frameCount++];
  frame->closure = _closure;
  frame->ip = _closure->function->chunk.code;
  frame->slots = vm->stackTop - 0 - 1;
  ObjString *name;
  Value constant,value,result;
  uint8_t slot;
  double a,b;
  ObjClosure *closure = newClosure((ObjFunction *) 0x558048e90db0);
  push(OBJ_VAL(closure));
  name = (ObjString *)0x558048e90d30;
  tableSet(&vm->globals, name, peek(0));
  pop();
  name = (ObjString *)0x558048e90d30;
  if (!tableGet(&vm->globals, name, &value)) {
      runtimeError("Undefined variable '%s'.", name->chars);
      return INTERPRET_RUNTIME_ERROR;
  }
  push(value);
  constant = 4607182418800017408UL;
  push(constant);
  if (!callValue(peek(1), 1)) {
      return INTERPRET_RUNTIME_ERROR;
  }
  frame = &vm->frames[vm->frameCount - 1];
  pop();
  name = (ObjString *)0x558048e90a00;
  if (!tableGet(&vm->globals, name, &value)) {
      runtimeError("Undefined variable '%s'.", name->chars);
      return INTERPRET_RUNTIME_ERROR;
  }
  push(value);
  if (!callValue(peek(0), 0)) {
      return INTERPRET_RUNTIME_ERROR;
  }
  frame = &vm->frames[vm->frameCount - 1];
  name = (ObjString *)0x558048e90ef0;
  tableSet(&vm->globals, name, peek(0));
  pop();
  name = (ObjString *)0x558048e90d30;
  if (!tableGet(&vm->globals, name, &value)) {
      runtimeError("Undefined variable '%s'.", name->chars);
      return INTERPRET_RUNTIME_ERROR;
  }
  push(value);
  constant = 4630122629401935872UL;
  push(constant);
  if (!callValue(peek(1), 1)) {
      return INTERPRET_RUNTIME_ERROR;
  }
  frame = &vm->frames[vm->frameCount - 1];
  pop();
  name = (ObjString *)0x558048e90a00;
  if (!tableGet(&vm->globals, name, &value)) {
      runtimeError("Undefined variable '%s'.", name->chars);
      return INTERPRET_RUNTIME_ERROR;
  }
  push(value);
  if (!callValue(peek(0), 0)) {
      return INTERPRET_RUNTIME_ERROR;
  }
  frame = &vm->frames[vm->frameCount - 1];
  name = (ObjString *)0x558048e90e20;
  tableSet(&vm->globals, name, peek(0));
  pop();
  name = (ObjString *)0x558048e90e20;
  if (!tableGet(&vm->globals, name, &value)) {
      runtimeError("Undefined variable '%s'.", name->chars);
      return INTERPRET_RUNTIME_ERROR;
  }
  push(value);
  name = (ObjString *)0x558048e90ef0;
  if (!tableGet(&vm->globals, name, &value)) {
      runtimeError("Undefined variable '%s'.", name->chars);
      return INTERPRET_RUNTIME_ERROR;
  }
  push(value);
  if (!IS_NUMBER(peek(0)) || !IS_NUMBER(peek(1))) {
      runtimeError("Operands must be numbers.");
      return INTERPRET_RUNTIME_ERROR; 
  }
  b = AS_NUMBER(pop());
  a = AS_NUMBER(pop());
  push(NUMBER_VAL(a - b)); 
  printValue(pop());
  printf("\n");
  push(NIL_VAL);
  result = pop();
  closeUpvalues(frame->slots);
  vm->frameCount--;
  if (vm->frameCount == 0) {
      pop();
      return INTERPRET_OK;
  }
  vm->stackTop = frame->slots;
  push(result);
  frame = &vm->frames[vm->frameCount - 1];
  return INTERPRET_OK;
  constant = 18445712183270116656UL;
  push(constant);
  return INTERPRET_OK;
}

